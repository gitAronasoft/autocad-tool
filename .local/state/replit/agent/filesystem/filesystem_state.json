{"file_contents":{"main.py":{"content":"from app import app\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)","size_bytes":98},"pyproject.toml":{"content":"[project]\nname = \"python-template\"\nversion = \"0.1.0\"\ndescription = \"\"\nauthors = [\"Your Name <you@example.com>\"]\nrequires-python = \">=3.11\"\ndependencies = [\n    \"ezdxf>=1.4.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"flask>=3.1.2\",\n    \"matplotlib>=3.10.6\",\n    \"numpy>=2.3.3\",\n    \"openai>=1.109.1\",\n    \"opencv-python>=4.11.0.86\",\n    \"pillow>=11.3.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"email-validator>=2.3.0\",\n    \"gunicorn>=23.0.0\",\n    \"werkzeug>=3.1.3\",\n]\n","size_bytes":460},"app.py":{"content":"import os\nimport json\nfrom flask import Flask, render_template, request, jsonify, send_file\nfrom werkzeug.utils import secure_filename\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nfrom src.architectural_analyzer import ArchitecturalAnalyzer\nfrom src.autocad_integration import AutoCADIntegration\nimport traceback\n\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\", \"dev-secret-key-change-in-production\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)  # needed for url_for to generate with https\napp.config['UPLOAD_FOLDER'] = 'uploads'\napp.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50MB max file size\n\n# Ensure upload directory exists\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\nos.makedirs('outputs', exist_ok=True)\n\nALLOWED_EXTENSIONS = {'dxf', 'dwg'}\n\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/')\ndef index():\n    \"\"\"Main upload page\"\"\"\n    return render_template('index.html')\n\n@app.route('/process', methods=['POST'])\ndef process_file():\n    \"\"\"Process uploaded DXF file with AI analysis\"\"\"\n    try:\n        # Check if file was uploaded\n        if 'dxf_file' not in request.files:\n            return jsonify({'success': False, 'error': 'No file uploaded'})\n        \n        file = request.files['dxf_file']\n        if file.filename == '':\n            return jsonify({'success': False, 'error': 'No file selected'})\n        \n        if not allowed_file(file.filename):\n            return jsonify({'success': False, 'error': 'Invalid file type. Please upload DXF or DWG files.'})\n        \n        # Save uploaded file\n        if file.filename:\n            filename = secure_filename(file.filename)\n            filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        else:\n            return jsonify({'success': False, 'error': 'Invalid filename'})\n        file.save(filepath)\n        \n        # Initialize AI analyzer and AutoCAD integration\n        analyzer = ArchitecturalAnalyzer()\n        autocad = AutoCADIntegration()\n        \n        # For DXF files, we need to convert to image for AI analysis\n        # For now, we'll load the DXF and process it directly\n        result = process_dxf_file(filepath, analyzer, autocad)\n        \n        return jsonify(result)\n        \n    except Exception as e:\n        print(f\"Error processing file: {str(e)}\")\n        traceback.print_exc()\n        return jsonify({'success': False, 'error': f'Processing error: {str(e)}'})\n\ndef process_dxf_file(filepath, analyzer, autocad):\n    \"\"\"Process a DXF file and return analysis results\"\"\"\n    try:\n        # Load the DXF file\n        success = autocad.load_dxf_file(filepath)\n        if not success:\n            return {'success': False, 'error': 'Could not load DXF file'}\n        \n        # Perform real DXF geometric analysis to extract wall patterns and coordinates\n        print(\"Starting real DXF geometric analysis...\")\n        \n        # Use the new geometric analysis method with AI enhancement instead of hardcoded coordinates\n        analysis_result = autocad.analyze_dxf_geometry(analyzer)\n        \n        layers_created = []\n        elements_detected = 0\n        \n        # Create layers dynamically based on real analysis results\n        for space in analysis_result.get('spaces', []):\n            layer_name = space['layer_name']\n            wall_type = space['type']\n            \n            # Get appropriate color for the wall type\n            color = autocad.get_layer_color(wall_type)\n            autocad.create_layer(layer_name, color)\n            layers_created.append(layer_name)\n        \n        # Create layers for any detected elements (doors, windows, etc.)\n        for element in analysis_result.get('elements', []):\n            layer_name = element['layer_name']\n            element_type = element['type']\n            \n            color = autocad.get_layer_color(element_type)\n            autocad.create_layer(layer_name, color)\n            if layer_name not in layers_created:\n                layers_created.append(layer_name)\n        \n        # Log analysis metadata for debugging\n        metadata = analysis_result.get('analysis_metadata', {})\n        if metadata:\n            print(f\"Analysis metadata:\")\n            print(f\"  Entities extracted: {metadata.get('entities_extracted', {})}\")\n            print(f\"  Wall groups found: {metadata.get('wall_groups_found', 0)}\")\n            if metadata.get('building_bounds'):\n                bounds = metadata['building_bounds']\n                print(f\"  Building bounds: {bounds['width']:.1f} x {bounds['height']:.1f} units\")\n            if metadata.get('fallback_used'):\n                print(\"  Warning: Using fallback analysis - no geometry detected\")\n        \n        # Execute the drawing commands\n        commands_executed = autocad.execute_autocad_commands(analysis_result)\n        elements_detected = commands_executed\n        \n        # Save the processed file\n        output_filename = f\"processed_{os.path.basename(filepath)}\"\n        output_path = os.path.join('outputs', output_filename)\n        autocad.save_dxf(output_path)\n        \n        return {\n            'success': True,\n            'analysis': {\n                'drawing_type': analysis_result['drawing_type'],\n                'layers_created': layers_created,\n                'elements_detected': elements_detected\n            },\n            'download_url': f'/download/{output_filename}'\n        }\n        \n    except Exception as e:\n        return {'success': False, 'error': f'DXF processing error: {str(e)}'}\n\n@app.route('/download/<filename>')\ndef download_file(filename):\n    \"\"\"Download processed DXF file\"\"\"\n    try:\n        return send_file(os.path.join('outputs', filename), as_attachment=True)\n    except Exception as e:\n        return jsonify({'error': f'Download error: {str(e)}'}), 404\n\nif __name__ == '__main__':\n    print(\"üöÄ Starting AI-Powered AutoCAD Analyzer Web Server...\")\n    print(\"üìÅ Upload folder:\", app.config['UPLOAD_FOLDER'])\n    print(\"üåê Access the interface at: http://localhost:5000\")\n    app.run(host='0.0.0.0', port=5000, debug=True)","size_bytes":6180},"demo.py":{"content":"import os\nfrom src.architectural_analyzer import ArchitecturalAnalyzer\nfrom src.autocad_integration import AutoCADIntegration\n\ndef main():\n    \"\"\"\n    Demo interface for the AI-powered AutoCAD plugin\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"AI-POWERED AUTOCAD ARCHITECTURAL ANALYZER\")\n    print(\"=\" * 60)\n    print()\n    \n    print(\"üèóÔ∏è  Welcome to your AI-powered AutoCAD plugin!\")\n    print(\"This tool can analyze architectural drawings and automatically:\")\n    print(\"‚Ä¢ Detect floor plans vs elevation drawings\")\n    print(\"‚Ä¢ Trace interior and exterior walls\")\n    print(\"‚Ä¢ Identify garage and buffered spaces\")\n    print(\"‚Ä¢ Detect doors and windows\")\n    print(\"‚Ä¢ Generate proper AutoCAD layer names\")\n    print(\"‚Ä¢ Create AutoCAD-compatible drawing commands\")\n    print()\n    \n    # Initialize components\n    print(\"üîß Initializing AI analyzer...\")\n    analyzer = ArchitecturalAnalyzer()\n    \n    print(\"üîß Initializing AutoCAD integration...\")\n    autocad = AutoCADIntegration()\n    \n    print(\"‚úÖ System ready!\")\n    print()\n    \n    # Demo the AutoCAD integration\n    print(\"üìã Creating sample AutoCAD output...\")\n    \n    # Create a new DXF document\n    autocad.create_new_dxf()\n    \n    # Create layers based on your requirements from the transcript\n    print(\"Creating layers for different wall types:\")\n    \n    # Basement layers\n    autocad.create_layer(\"basement_interior_wall\", color=1)  # Red\n    autocad.create_layer(\"basement_exterior_wall\", color=2)  # Yellow\n    \n    # Main floor layers  \n    autocad.create_layer(\"main_floor_interior_wall\", color=1)  # Red\n    autocad.create_layer(\"main_floor_exterior_wall\", color=2)  # Yellow\n    autocad.create_layer(\"main_floor_garage_wall\", color=3)    # Green (buffered space)\n    \n    # Door and window layers\n    autocad.create_layer(\"front_door_main\", color=4)      # Cyan\n    autocad.create_layer(\"front_window_main\", color=5)    # Blue\n    autocad.create_layer(\"patio_door_main\", color=6)      # Magenta\n    \n    print(\"‚úÖ Layers created successfully!\")\n    \n    # Draw sample architectural elements\n    print(\"Drawing sample walls and elements...\")\n    \n    # Sample basement exterior wall (house perimeter)\n    basement_exterior = [(0, 0), (200, 0), (200, 150), (0, 150), (0, 0)]\n    autocad.draw_polyline(basement_exterior, \"basement_exterior_wall\")\n    \n    # Sample basement interior wall (inside the house)\n    basement_interior = [(20, 20), (180, 20), (180, 130), (20, 130), (20, 20)]\n    autocad.draw_polyline(basement_interior, \"basement_interior_wall\")\n    \n    # Sample garage area (main floor with buffered wall)\n    garage_wall = [(50, 0), (120, 0), (120, 60), (50, 60)]\n    autocad.draw_polyline(garage_wall, \"main_floor_garage_wall\")\n    \n    # Sample doors\n    autocad.draw_rectangle((90, 0), (110, 8), \"front_door_main\")      # Front door\n    autocad.draw_rectangle((150, 80), (170, 88), \"patio_door_main\")   # Patio door\n    \n    # Sample windows\n    autocad.draw_rectangle((30, 0), (45, 5), \"front_window_main\")     # Front window\n    \n    print(\"‚úÖ Sample elements drawn!\")\n    \n    # Save the output file\n    output_file = \"AI_analyzed_drawing.dxf\"\n    autocad.save_dxf(output_file)\n    \n    print(f\"üìÅ AutoCAD file saved as: {output_file}\")\n    \n    # List all created layers\n    print(\"\\nüìä Created layers:\")\n    layers = autocad.list_layers()\n    for layer in layers:\n        print(f\"   ‚Ä¢ {layer['name']} (Color: {layer['color']})\")\n    \n    print(\"\\n\" + \"=\" * 60)\n    print(\"READY FOR AI ANALYSIS!\")\n    print(\"=\" * 60)\n    print()\n    print(\"Your AI-powered AutoCAD plugin is ready to:\")\n    print(\"1. Analyze uploaded architectural drawings (PDF or DXF)\")\n    print(\"2. Automatically detect walls, doors, windows\")\n    print(\"3. Generate proper layer names and colors\")\n    print(\"4. Create AutoCAD-compatible output\")\n    print()\n    print(\"To use with your drawings:\")\n    print(\"‚Ä¢ Upload architectural drawings to the project\")\n    print(\"‚Ä¢ The AI will analyze and detect building elements\")\n    print(\"‚Ä¢ Proper AutoCAD layers and geometry will be created\")\n    print(\"‚Ä¢ Review and import into your AutoCAD workflow\")\n    print()\n    print(\"üöÄ Plugin demonstration completed successfully!\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":4265},"replit.md":{"content":"# AI-Powered AutoCAD Analyzer\n\n## Overview\n\nThis is an AI-powered architectural drawing analysis tool that integrates with AutoCAD to automatically process DXF/DWG files. The system uses computer vision and OpenAI's GPT models to analyze architectural drawings, detect building elements (walls, doors, windows), classify floor types (basement, main floor, second floor), and automatically generate properly named AutoCAD layers. The application provides both a web interface for file uploads and a command-line demo interface for testing functionality.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n- **Web Interface**: Flask-based web application with Bootstrap CSS framework\n- **File Upload System**: Drag-and-drop interface supporting DXF and DWG files up to 50MB\n- **Real-time Feedback**: AJAX-based file processing with progress indicators\n- **Responsive Design**: Mobile-friendly interface using Bootstrap grid system\n\n### Backend Architecture\n- **Framework**: Flask web framework for HTTP request handling\n- **Modular Design**: Separation of concerns with dedicated modules for AI analysis and AutoCAD integration\n- **File Processing Pipeline**: Secure file upload handling with filename sanitization and type validation\n- **Error Handling**: Comprehensive exception handling with user-friendly error messages\n\n### Core Components\n- **ArchitecturalAnalyzer**: Main AI analysis engine that processes architectural drawings using OpenAI's vision models\n- **AutoCADIntegration**: Handles DXF file creation, layer management, and AutoCAD-compatible output generation\n- **Layer Management System**: Predefined naming conventions for different building elements and floor types\n\n### AI Integration\n- **Vision Analysis**: Uses OpenAI's latest GPT model for image analysis and element detection\n- **Element Detection**: Automatically identifies walls (interior/exterior), doors, windows, and garage spaces\n- **Floor Classification**: Distinguishes between basement, main floor, and second floor plans\n- **Smart Layer Naming**: Generates contextually appropriate AutoCAD layer names based on building elements\n\n### Data Processing\n- **File Format Support**: Handles both DXF and DWG file formats using ezdxf library\n- **Image Processing**: OpenCV and PIL for image manipulation and analysis\n- **Vector Graphics**: Direct manipulation of CAD vector data for precise element detection\n\n## External Dependencies\n\n### AI Services\n- **OpenAI API**: GPT models for architectural drawing analysis and element detection\n- **Computer Vision**: OpenCV for image processing and feature detection\n\n### CAD Integration\n- **ezdxf**: Python library for reading, writing, and manipulating DXF files\n- **AutoCAD Compatibility**: Generates R2010 format DXF files for broad compatibility\n\n### Web Framework\n- **Flask**: Python web framework for request handling and routing\n- **Bootstrap**: Frontend CSS framework for responsive design\n- **Font Awesome**: Icon library for user interface elements\n\n### File Processing\n- **Werkzeug**: Secure filename handling and file upload utilities\n- **PIL (Pillow)**: Image processing and format conversion\n- **NumPy**: Numerical operations for image and vector data processing\n\n### Environment Configuration\n- **Environment Variables**: OpenAI API key configuration through environment variables\n- **File System**: Local file storage for uploads and outputs with automatic directory creation","size_bytes":3493},"src/__init__.py":{"content":"# AI-Powered AutoCAD Plugin Package","size_bytes":35},"src/architectural_analyzer.py":{"content":"import os\nimport json\nimport base64\nimport cv2\nimport numpy as np\nfrom PIL import Image\nfrom openai import OpenAI\nimport ezdxf\nfrom typing import Dict, List, Tuple, Optional\n\n# the newest OpenAI model is \"gpt-5-mini\" which was released August 7, 2025.\n# do not change this unless explicitly requested by the user\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\nopenai = None\nif OPENAI_API_KEY:\n    openai = OpenAI(api_key=OPENAI_API_KEY)\nelse:\n    print(\"Warning: OPENAI_API_KEY not found. AI analysis will be disabled.\")\n\nclass ArchitecturalAnalyzer:\n    \"\"\"\n    AI-powered architectural drawing analyzer that can:\n    1. Detect floor plans vs elevations\n    2. Identify interior/exterior walls, garage spaces, doors, windows\n    3. Generate proper layer names for AutoCAD\n    4. Trace walls and create AutoCAD-compatible output\n    \"\"\"\n    \n    def __init__(self):\n        self.layer_names = {\n            'basement': {\n                'interior': 'basement_interior_wall',\n                'exterior': 'basement_exterior_wall'\n            },\n            'main_floor': {\n                'interior': 'main_floor_interior_wall',\n                'exterior': 'main_floor_exterior_wall',\n                'garage': 'main_floor_garage_wall'\n            },\n            'second_floor': {\n                'interior': 'second_floor_interior_wall',\n                'exterior': 'second_floor_exterior_wall'\n            },\n            'doors': {\n                'front': 'front_door_main',\n                'back': 'back_door_main',\n                'patio': 'patio_door_main',\n                'garage': 'garage_door_main'\n            },\n            'windows': {\n                'front': 'front_window_main',\n                'back': 'back_window_main',\n                'side': 'side_window_main',\n                'door': 'door_window_main'\n            }\n        }\n    \n    def encode_image_to_base64(self, image_path: str) -> str:\n        \"\"\"Convert image file to base64 string for OpenAI API\"\"\"\n        with open(image_path, \"rb\") as image_file:\n            return base64.b64encode(image_file.read()).decode('utf-8')\n    \n    def analyze_drawing_type(self, image_path: str) -> Dict:\n        \"\"\"\n        Determine if the drawing is a floor plan or elevation using AI\n        \"\"\"\n        if not openai:\n            raise Exception(\"OpenAI API key not configured. Please set up your OpenAI API key to use AI analysis features.\")\n        \n        base64_image = self.encode_image_to_base64(image_path)\n        \n        response = openai.chat.completions.create(\n            model=\"gpt-5-mini\",\n            messages=[\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are an expert in architectural drawings. Analyze the image and determine if it's a floor plan (top-down view showing room layouts) or an elevation (side view showing the exterior facade of a building). Respond with JSON format: {'type': 'floor_plan' or 'elevation', 'confidence': 0.0-1.0, 'reasoning': 'explanation'}\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": [\n                        {\n                            \"type\": \"text\",\n                            \"text\": \"Analyze this architectural drawing and determine if it's a floor plan or elevation view.\"\n                        },\n                        {\n                            \"type\": \"image_url\",\n                            \"image_url\": {\"url\": f\"data:image/jpeg;base64,{base64_image}\"}\n                        }\n                    ]\n                }\n            ],\n            response_format={\"type\": \"json_object\"},\n            timeout=20.0\n        )\n        \n        content = response.choices[0].message.content\n        if content is None:\n            raise ValueError(\"Empty response content from OpenAI API for drawing type analysis\")\n        result = json.loads(content)\n        return result\n    \n    def analyze_floor_plan(self, image_path: str) -> Dict:\n        \"\"\"\n        Analyze floor plan to detect walls, rooms, and spaces\n        \"\"\"\n        if not openai:\n            raise Exception(\"OpenAI API key not configured. Please set up your OpenAI API key to use AI analysis features.\")\n        \n        base64_image = self.encode_image_to_base64(image_path)\n        \n        prompt = \"\"\"\n        You are an expert architectural analyst. Analyze this floor plan and identify:\n        \n        1. Floor type (basement, main_floor, second_floor, etc.)\n        2. Interior walls (walls inside the house)\n        3. Exterior walls (walls forming the house perimeter)\n        4. Garage spaces (unheated but enclosed areas)\n        5. Buffered/protected walls (walls adjacent to garage or other unheated spaces)\n        6. Room types and their boundaries\n        \n        For each wall or space, provide coordinates where lines should be drawn to trace:\n        - Interior walls\n        - Exterior walls  \n        - Garage-adjacent walls (different from full exterior)\n        \n        Respond in JSON format with:\n        {\n            \"floor_type\": \"basement/main_floor/second_floor\",\n            \"spaces\": [\n                {\n                    \"type\": \"interior/exterior/garage_adjacent\",\n                    \"coordinates\": [[x1,y1], [x2,y2], ...],\n                    \"layer_name\": \"suggested_layer_name\"\n                }\n            ],\n            \"rooms\": [\n                {\n                    \"type\": \"living_room/kitchen/garage/etc\",\n                    \"boundaries\": [[x1,y1], [x2,y2], ...]\n                }\n            ]\n        }\n        \"\"\"\n        \n        response = openai.chat.completions.create(\n            model=\"gpt-5-mini\",\n            messages=[\n                {\n                    \"role\": \"system\",\n                    \"content\": prompt\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": [\n                        {\n                            \"type\": \"text\",\n                            \"text\": \"Analyze this floor plan drawing for wall detection and space identification.\"\n                        },\n                        {\n                            \"type\": \"image_url\",\n                            \"image_url\": {\"url\": f\"data:image/jpeg;base64,{base64_image}\"}\n                        }\n                    ]\n                }\n            ],\n            response_format={\"type\": \"json_object\"},\n            timeout=20.0\n        )\n        \n        content = response.choices[0].message.content\n        if content is None:\n            raise ValueError(\"Empty response content from OpenAI API for floor plan analysis\")\n        result = json.loads(content)\n        return result\n    \n    def analyze_elevation(self, image_path: str) -> Dict:\n        \"\"\"\n        Analyze elevation to detect doors, windows, and their dimensions\n        \"\"\"\n        if not openai:\n            raise Exception(\"OpenAI API key not configured. Please set up your OpenAI API key to use AI analysis features.\")\n        \n        base64_image = self.encode_image_to_base64(image_path)\n        \n        prompt = \"\"\"\n        You are an expert architectural analyst. Analyze this elevation drawing and identify:\n        \n        1. Elevation direction (front, back, left, right)\n        2. Doors (front door, patio door, etc.) with dimensions if visible\n        3. Windows with their locations and sizes\n        4. Door windows (windows within doors)\n        \n        For each element, provide:\n        - Type (door/window)\n        - Subtype (front_door, patio_door, regular_window, door_window)\n        - Coordinates for drawing the element outline\n        - Dimensions if visible (e.g., \"36x80\" for doors)\n        - Floor level (main, basement, second, etc.)\n        \n        Respond in JSON format with:\n        {\n            \"elevation_direction\": \"front/back/left/right\",\n            \"elements\": [\n                {\n                    \"type\": \"door/window\",\n                    \"subtype\": \"front_door/patio_door/window/door_window\",\n                    \"coordinates\": [[x1,y1], [x2,y2], [x3,y3], [x4,y4]],\n                    \"dimensions\": \"36x80\" or null,\n                    \"floor_level\": \"main/basement/second\",\n                    \"layer_name\": \"suggested_layer_name\"\n                }\n            ]\n        }\n        \"\"\"\n        \n        response = openai.chat.completions.create(\n            model=\"gpt-5-mini\",\n            messages=[\n                {\n                    \"role\": \"system\",\n                    \"content\": prompt\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": [\n                        {\n                            \"type\": \"text\",\n                            \"text\": \"Analyze this elevation drawing for door and window detection.\"\n                        },\n                        {\n                            \"type\": \"image_url\",\n                            \"image_url\": {\"url\": f\"data:image/jpeg;base64,{base64_image}\"}\n                        }\n                    ]\n                }\n            ],\n            response_format={\"type\": \"json_object\"},\n            timeout=20.0\n        )\n        \n        content = response.choices[0].message.content\n        if content is None:\n            raise ValueError(\"Empty response content from OpenAI API for elevation analysis\")\n        result = json.loads(content)\n        return result\n    \n    def process_drawing(self, image_path: str) -> Dict:\n        \"\"\"\n        Main processing function that analyzes any architectural drawing\n        and returns comprehensive analysis with AutoCAD instructions\n        \"\"\"\n        # First determine drawing type\n        drawing_type_analysis = self.analyze_drawing_type(image_path)\n        \n        analysis_type = drawing_type_analysis.get('type')\n        if analysis_type == 'floor_plan':\n            analysis = self.analyze_floor_plan(image_path)\n            analysis['drawing_type'] = 'floor_plan'\n        else:\n            analysis = self.analyze_elevation(image_path)\n            analysis['drawing_type'] = 'elevation'\n        \n        analysis['type_analysis'] = drawing_type_analysis\n        \n        return analysis\n    \n    def analyze_geometric_data(self, geometric_data: Dict, spatial_analysis: Dict) -> Dict:\n        \"\"\"\n        Analyze geometric data using AI to enhance wall classification and spatial understanding\n        \"\"\"\n        if not openai:\n            raise Exception(\"OpenAI API key not configured. Please set up your OpenAI API key to use AI analysis features.\")\n\n        try:\n            print(\"Starting OpenAI API call for geometric analysis...\")\n            # Prepare geometric data summary for AI analysis\n            analysis_prompt = self._create_geometric_analysis_prompt(geometric_data, spatial_analysis)\n            \n            # Add shorter timeout to prevent hanging on large files\n            response = openai.chat.completions.create(\n                model=\"gpt-5-mini\",\n                messages=[\n                    {\n                        \"role\": \"system\",\n                        \"content\": \"\"\"You are an expert architectural analyst specializing in CAD drawing interpretation. \n                        Analyze the geometric data from a DXF file to classify walls, spaces, and architectural elements.\n                        Focus on spatial relationships, connectivity patterns, and architectural logic.\"\"\"\n                    },\n                    {\n                        \"role\": \"user\",\n                        \"content\": analysis_prompt\n                    }\n                ],\n                response_format={\"type\": \"json_object\"},\n                timeout=10.0  # Reduced to 10 second timeout\n            )\n            \n            content = response.choices[0].message.content\n            if content is None:\n                raise ValueError(\"Empty response content from OpenAI API for geometric analysis\")\n            ai_analysis = json.loads(content)\n            \n            # Enhance the spatial analysis with AI insights\n            enhanced_analysis = self._merge_ai_with_geometric_analysis(ai_analysis, spatial_analysis)\n            \n            print(\"AI-enhanced geometric analysis completed\")\n            return enhanced_analysis\n\n        except Exception as e:\n            error_msg = f\"AI analysis failed: {str(e)}\"\n            print(f\"Error in AI geometric analysis: {e}\")\n            raise Exception(error_msg)\n\n    def _create_geometric_analysis_prompt(self, geometric_data: Dict, spatial_analysis: Dict) -> str:\n        \"\"\"Create a prompt for AI analysis of geometric data\"\"\"\n        \n        # Summarize the geometric data\n        entities_summary = geometric_data.get('entities_extracted', {})\n        wall_groups = spatial_analysis.get('wall_groups_found', 0)\n        building_bounds = spatial_analysis.get('building_bounds', {})\n        \n        prompt = f\"\"\"\n        Analyze this architectural DXF file geometric data:\n\n        GEOMETRIC ENTITIES FOUND:\n        - Lines: {entities_summary.get('lines', 0)}\n        - Polylines: {entities_summary.get('polylines', 0)}\n        - Arcs: {entities_summary.get('arcs', 0)}\n        - Circles: {entities_summary.get('circles', 0)}\n\n        SPATIAL ANALYSIS:\n        - Wall groups identified: {wall_groups}\n        - Building dimensions: {building_bounds.get('width', 'unknown')} x {building_bounds.get('height', 'unknown')} units\n        - Building bounds: {building_bounds}\n\n        WALL GROUP DETAILS:\n        \"\"\"\n        \n        # Add details about each wall group from spatial analysis\n        if 'wall_groups' in spatial_analysis:\n            for i, group in enumerate(spatial_analysis['wall_groups'][:5]):  # Limit to first 5 for prompt size\n                prompt += f\"\"\"\n        Wall Group {i+1}:\n        - Total length: {group.get('total_length', 0):.1f} units\n        - Segment count: {len(group.get('segments', []))}\n        - Layers involved: {list(group.get('layers', set()))}\n        - Bounds: {group.get('bounds', {})}\n        \"\"\"\n\n        prompt += \"\"\"\n\n        ANALYSIS REQUIRED:\n        Based on this geometric data, provide architectural classification:\n\n        1. For each wall group, determine:\n           - Type: 'exterior', 'interior', or 'garage_adjacent'\n           - Reasoning based on position, connectivity, and architectural logic\n           - Confidence level (0.0-1.0)\n\n        2. Identify potential room spaces and their characteristics\n\n        3. Suggest appropriate layer naming following these patterns:\n           - Exterior walls: '[floor]_exterior_wall_[n]' \n           - Interior walls: '[floor]_interior_wall_[n]'\n           - Garage walls: '[floor]_garage_wall_[n]'\n\n        Respond in JSON format:\n        {\n            \"wall_classifications\": [\n                {\n                    \"group_index\": 0,\n                    \"type\": \"exterior/interior/garage_adjacent\",\n                    \"confidence\": 0.0-1.0,\n                    \"reasoning\": \"explanation\",\n                    \"suggested_layer\": \"layer_name\"\n                }\n            ],\n            \"spatial_insights\": {\n                \"building_type\": \"residential/commercial/mixed\",\n                \"floor_count_estimate\": 1-3,\n                \"has_garage\": true/false,\n                \"architectural_style\": \"description\"\n            },\n            \"recommendations\": [\n                \"specific suggestions for layer organization or analysis improvements\"\n            ]\n        }\n        \"\"\"\n        \n        return prompt\n\n    def _merge_ai_with_geometric_analysis(self, ai_analysis: Dict, spatial_analysis: Dict) -> Dict:\n        \"\"\"Merge AI insights with geometric analysis results\"\"\"\n        \n        enhanced_analysis = spatial_analysis.copy()\n        enhanced_analysis['ai_insights'] = ai_analysis\n        \n        # Apply AI classifications to wall groups\n        wall_classifications = ai_analysis.get('wall_classifications', [])\n        \n        if 'wall_groups' in enhanced_analysis:\n            for classification in wall_classifications:\n                group_index = classification.get('group_index', 0)\n                if group_index < len(enhanced_analysis['wall_groups']):\n                    group = enhanced_analysis['wall_groups'][group_index]\n                    group['ai_classification'] = {\n                        'type': classification.get('type', 'interior'),\n                        'confidence': classification.get('confidence', 0.5),\n                        'reasoning': classification.get('reasoning', ''),\n                        'suggested_layer': classification.get('suggested_layer', '')\n                    }\n\n        # Add spatial insights\n        enhanced_analysis['spatial_insights'] = ai_analysis.get('spatial_insights', {})\n        enhanced_analysis['ai_recommendations'] = ai_analysis.get('recommendations', [])\n        \n        return enhanced_analysis\n\n    def _create_basic_analysis(self, geometric_data: Dict, spatial_analysis: Dict) -> Dict:\n        \"\"\"Create basic analysis when AI is not available\"\"\"\n        \n        basic_analysis = spatial_analysis.copy()\n        basic_analysis['ai_insights'] = {\n            \"note\": \"AI analysis not available - using geometric analysis only\",\n            \"wall_classifications\": [],\n            \"spatial_insights\": {\n                \"building_type\": \"unknown\",\n                \"analysis_method\": \"geometric_only\"\n            }\n        }\n        \n        return basic_analysis\n    \n    def generate_autocad_commands(self, analysis: Dict) -> List[str]:\n        \"\"\"\n        Generate AutoCAD command sequence based on analysis results\n        \"\"\"\n        commands = []\n        \n        if analysis['drawing_type'] == 'floor_plan':\n            # Generate commands for wall tracing\n            for space in analysis.get('spaces', []):\n                layer_name = space['layer_name']\n                coords = space['coordinates']\n                \n                # Create layer\n                commands.append(f\"-LAYER M {layer_name}\")\n                \n                # Draw polyline for wall tracing\n                if len(coords) > 1:\n                    polyline_cmd = \"PLINE \"\n                    for coord in coords:\n                        polyline_cmd += f\"{coord[0]},{coord[1]} \"\n                    polyline_cmd += \"C\"  # Close polyline\n                    commands.append(polyline_cmd)\n        \n        elif analysis['drawing_type'] == 'elevation':\n            # Generate commands for doors and windows\n            for element in analysis.get('elements', []):\n                layer_name = element['layer_name']\n                coords = element['coordinates']\n                \n                # Create layer\n                commands.append(f\"-LAYER M {layer_name}\")\n                \n                # Draw rectangle for door/window\n                if len(coords) >= 4:\n                    rect_cmd = f\"RECTANG {coords[0][0]},{coords[0][1]} {coords[2][0]},{coords[2][1]}\"\n                    commands.append(rect_cmd)\n        \n        return commands\n\ndef main():\n    \"\"\"\n    Example usage of the ArchitecturalAnalyzer\n    \"\"\"\n    analyzer = ArchitecturalAnalyzer()\n    \n    # Example usage - you would replace this with actual file paths\n    print(\"Architectural Drawing Analyzer initialized\")\n    print(\"Ready to process AutoCAD drawings and PDFs\")\n    print(\"\\nSupported operations:\")\n    print(\"1. Detect floor plans vs elevations\")\n    print(\"2. Trace interior/exterior walls\")\n    print(\"3. Identify garage and buffered spaces\")\n    print(\"4. Detect doors and windows in elevations\")\n    print(\"5. Generate proper AutoCAD layer names\")\n    print(\"6. Create AutoCAD command sequences\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":19710},"src/autocad_integration.py":{"content":"import ezdxf\nimport os\nfrom typing import List, Dict, Tuple, Optional, Any, Union\nimport cv2\nimport numpy as np\nfrom PIL import Image\nimport math\nfrom collections import defaultdict\n\nclass AutoCADIntegration:\n    \"\"\"\n    Handles AutoCAD file operations and layer management\n    \"\"\"\n    \n    def __init__(self):\n        self.current_doc = None\n        self.modelspace = None\n    \n    def load_dxf_file(self, file_path: str) -> bool:\n        \"\"\"Load an existing DXF file\"\"\"\n        try:\n            # Type-safe access to ezdxf.readfile\n            readfile_func = getattr(ezdxf, 'readfile', None)\n            if readfile_func is None:\n                print(\"Error: ezdxf.readfile not available\")\n                return False\n            self.current_doc = readfile_func(file_path)\n            self.modelspace = self.current_doc.modelspace()\n            print(f\"Successfully loaded DXF file: {file_path}\")\n            return True\n        except Exception as e:\n            print(f\"Error loading DXF file: {e}\")\n            return False\n    \n    def create_new_dxf(self) -> bool:\n        \"\"\"Create a new DXF document\"\"\"\n        try:\n            # Type-safe access to ezdxf.new\n            new_func = getattr(ezdxf, 'new', None)\n            if new_func is None:\n                print(\"Error: ezdxf.new not available\")\n                return False\n            self.current_doc = new_func('R2010')\n            self.modelspace = self.current_doc.modelspace()\n            print(\"Created new DXF document\")\n            return True\n        except Exception as e:\n            print(f\"Error creating new DXF document: {e}\")\n            return False\n    \n    def create_layer(self, layer_name: str, color: int = 7, linetype: str = 'CONTINUOUS'):\n        \"\"\"Create a new layer in the DXF file\"\"\"\n        if self.current_doc is None:\n            print(\"No DXF document loaded\")\n            return False\n        \n        try:\n            layers = self.current_doc.layers\n            if layer_name not in layers:\n                layer = layers.new(name=layer_name)\n                # Type-safe attribute setting\n                if hasattr(layer, 'color'):\n                    layer.color = color\n                if hasattr(layer.dxf, 'linetype'):\n                    layer.dxf.linetype = linetype\n                print(f\"Created layer: {layer_name}\")\n            else:\n                print(f\"Layer {layer_name} already exists\")\n            return True\n        except Exception as e:\n            print(f\"Error creating layer {layer_name}: {e}\")\n            return False\n    \n    def draw_polyline(self, coordinates: List[Tuple[float, float]], layer_name: str = \"0\"):\n        \"\"\"Draw a polyline on the specified layer\"\"\"\n        if self.current_doc is None or self.modelspace is None:\n            print(\"No DXF document loaded\")\n            return False\n        \n        try:\n            # Convert 2D coordinates to 3D (adding z=0)\n            points_3d = [(x, y, 0) for x, y in coordinates]\n            \n            polyline = self.modelspace.add_lwpolyline(points_3d)\n            polyline.dxf.layer = layer_name\n            print(f\"Drew polyline with {len(coordinates)} points on layer {layer_name}\")\n            return True\n        except Exception as e:\n            print(f\"Error drawing polyline: {e}\")\n            return False\n    \n    def draw_rectangle(self, point1: Tuple[float, float], point2: Tuple[float, float], layer_name: str = \"0\"):\n        \"\"\"Draw a rectangle between two points\"\"\"\n        if self.current_doc is None or self.modelspace is None:\n            print(\"No DXF document loaded\")\n            return False\n        \n        try:\n            x1, y1 = point1\n            x2, y2 = point2\n            \n            # Create rectangle coordinates\n            rectangle_points = [\n                (x1, y1),\n                (x2, y1),\n                (x2, y2),\n                (x1, y2),\n                (x1, y1)  # Close the rectangle\n            ]\n            \n            return self.draw_polyline(rectangle_points, layer_name)\n        except Exception as e:\n            print(f\"Error drawing rectangle: {e}\")\n            return False\n    \n    def draw_line(self, start_point: Tuple[float, float], end_point: Tuple[float, float], layer_name: str = \"0\"):\n        \"\"\"Draw a single line\"\"\"\n        if self.current_doc is None or self.modelspace is None:\n            print(\"No DXF document loaded\")\n            return False\n        \n        try:\n            start_3d = (start_point[0], start_point[1], 0)\n            end_3d = (end_point[0], end_point[1], 0)\n            \n            line = self.modelspace.add_line(start_3d, end_3d)\n            line.dxf.layer = layer_name\n            print(f\"Drew line from {start_point} to {end_point} on layer {layer_name}\")\n            return True\n        except Exception as e:\n            print(f\"Error drawing line: {e}\")\n            return False\n    \n    def save_dxf(self, output_path: str):\n        \"\"\"Save the current DXF document\"\"\"\n        if self.current_doc is None:\n            print(\"No DXF document to save\")\n            return False\n        \n        try:\n            self.current_doc.saveas(output_path)\n            print(f\"Saved DXF file to: {output_path}\")\n            return True\n        except Exception as e:\n            print(f\"Error saving DXF file: {e}\")\n            return False\n    \n    def list_layers(self):\n        \"\"\"List all layers in the current document\"\"\"\n        if self.current_doc is None:\n            print(\"No DXF document loaded\")\n            return []\n        \n        layers = []\n        for layer in self.current_doc.layers:\n            layers.append({\n                'name': layer.dxf.name,\n                'color': layer.dxf.color,\n                'linetype': layer.dxf.linetype\n            })\n        \n        return layers\n    \n    def execute_autocad_commands(self, analysis_result: Dict):\n        \"\"\"\n        Execute AutoCAD drawing commands based on AI analysis results\n        \"\"\"\n        if self.current_doc is None:\n            print(\"No DXF document loaded. Creating new document.\")\n            self.create_new_dxf()\n        \n        commands_executed = 0\n        \n        if analysis_result['drawing_type'] == 'floor_plan':\n            print(\"Processing floor plan analysis...\")\n            \n            # Process spaces (walls)\n            for space in analysis_result.get('spaces', []):\n                layer_name = space['layer_name']\n                coordinates = space['coordinates']\n                \n                # Create layer\n                color = self.get_layer_color(space['type'])\n                self.create_layer(layer_name, color)\n                \n                # Draw the wall trace\n                if len(coordinates) > 1:\n                    self.draw_polyline(coordinates, layer_name)\n                    commands_executed += 1\n        \n        elif analysis_result['drawing_type'] == 'elevation':\n            print(\"Processing elevation analysis...\")\n            \n            # Process doors and windows\n            for element in analysis_result.get('elements', []):\n                layer_name = element['layer_name']\n                coordinates = element['coordinates']\n                \n                # Create layer\n                color = self.get_layer_color(element['type'])\n                self.create_layer(layer_name, color)\n                \n                # Draw rectangle for door/window\n                if len(coordinates) >= 4:\n                    point1 = coordinates[0]\n                    point2 = coordinates[2]  # Diagonal point\n                    self.draw_rectangle(point1, point2, layer_name)\n                    commands_executed += 1\n        \n        print(f\"Executed {commands_executed} drawing commands\")\n        return commands_executed\n    \n    def get_layer_color(self, element_type: str) -> int:\n        \"\"\"Get appropriate color for different element types\"\"\"\n        color_map = {\n            'interior': 1,      # Red\n            'exterior': 2,      # Yellow\n            'garage_adjacent': 3, # Green\n            'door': 4,          # Cyan\n            'window': 5,        # Blue\n            'garage': 6         # Magenta\n        }\n        return color_map.get(element_type, 7)  # Default white\n\n    def extract_geometric_entities(self) -> Dict[str, List]:\n        \"\"\"\n        Extract all geometric entities from the loaded DXF document\n        Returns a dictionary with entity types and their data\n        \"\"\"\n        if self.current_doc is None or self.modelspace is None:\n            print(\"No DXF document loaded\")\n            return {}\n\n        entities = {\n            'lines': [],\n            'polylines': [],\n            'lwpolylines': [],\n            'arcs': [],\n            'circles': [],\n            'splines': [],\n            'blocks': [],\n            'text': []\n        }\n\n        try:\n            for entity in self.modelspace:\n                entity_type = entity.dxftype()\n                \n                if entity_type == 'LINE':\n                    entities['lines'].append({\n                        'start': (entity.dxf.start.x, entity.dxf.start.y),\n                        'end': (entity.dxf.end.x, entity.dxf.end.y),\n                        'layer': entity.dxf.layer,\n                        'length': math.sqrt((entity.dxf.end.x - entity.dxf.start.x)**2 + \n                                          (entity.dxf.end.y - entity.dxf.start.y)**2)\n                    })\n                \n                elif entity_type == 'LWPOLYLINE':\n                    # Type-safe access to entity methods and attributes\n                    get_points_method = getattr(entity, 'get_points', None)\n                    if get_points_method is not None:\n                        try:\n                            points_data = get_points_method('xy')\n                            points = [(point[0], point[1]) for point in points_data]\n                        except (IndexError, TypeError):\n                            # Fallback to vertices method\n                            vertices_method = getattr(entity, 'vertices', None)\n                            if vertices_method is not None:\n                                points = list(vertices_method())\n                            else:\n                                points = []\n                    else:\n                        points = []\n                    \n                    # Type-safe access to closed attribute\n                    is_closed = getattr(entity, 'closed', False)\n                    \n                    entities['lwpolylines'].append({\n                        'points': points,\n                        'layer': getattr(entity.dxf, 'layer', '0'),\n                        'closed': is_closed,\n                        'area': self._calculate_polygon_area(points) if is_closed else 0\n                    })\n                \n                elif entity_type == 'POLYLINE':\n                    # Type-safe access to vertices\n                    vertices_attr = getattr(entity, 'vertices', None)\n                    if vertices_attr is not None:\n                        try:\n                            points = []\n                            for vertex in vertices_attr:\n                                if hasattr(vertex, 'dxf') and hasattr(vertex.dxf, 'location'):\n                                    location = vertex.dxf.location\n                                    if hasattr(location, 'x') and hasattr(location, 'y'):\n                                        points.append((location.x, location.y))\n                        except (AttributeError, TypeError):\n                            points = []\n                    else:\n                        points = []\n                    \n                    # Type-safe access to is_closed method\n                    is_closed_method = getattr(entity, 'is_closed', None)\n                    if callable(is_closed_method):\n                        try:\n                            is_closed = is_closed_method()\n                        except Exception:\n                            is_closed = False\n                    else:\n                        is_closed = False\n                    \n                    entities['polylines'].append({\n                        'points': points,\n                        'layer': getattr(entity.dxf, 'layer', '0'),\n                        'closed': is_closed,\n                        'area': self._calculate_polygon_area(points) if is_closed else 0\n                    })\n                \n                elif entity_type == 'ARC':\n                    entities['arcs'].append({\n                        'center': (entity.dxf.center.x, entity.dxf.center.y),\n                        'radius': entity.dxf.radius,\n                        'start_angle': entity.dxf.start_angle,\n                        'end_angle': entity.dxf.end_angle,\n                        'layer': entity.dxf.layer\n                    })\n                \n                elif entity_type == 'CIRCLE':\n                    entities['circles'].append({\n                        'center': (entity.dxf.center.x, entity.dxf.center.y),\n                        'radius': entity.dxf.radius,\n                        'layer': entity.dxf.layer,\n                        'area': math.pi * entity.dxf.radius**2\n                    })\n\n            print(f\"Extracted {len(entities['lines'])} lines, {len(entities['lwpolylines'])} lwpolylines, \"\n                  f\"{len(entities['polylines'])} polylines, {len(entities['arcs'])} arcs, \"\n                  f\"{len(entities['circles'])} circles\")\n            \n            return entities\n\n        except Exception as e:\n            print(f\"Error extracting geometric entities: {e}\")\n            return {}\n\n    def _calculate_polygon_area(self, points: List[Tuple[float, float]]) -> float:\n        \"\"\"Calculate the area of a polygon using the shoelace formula\"\"\"\n        if len(points) < 3:\n            return 0\n        \n        area = 0\n        n = len(points)\n        for i in range(n):\n            j = (i + 1) % n\n            area += points[i][0] * points[j][1]\n            area -= points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    def analyze_spatial_relationships(self, entities: Dict[str, List]) -> Dict:\n        \"\"\"\n        Analyze spatial relationships between entities to identify wall patterns\n        \"\"\"\n        analysis = {\n            'potential_walls': [],\n            'enclosed_areas': [],\n            'wall_groups': [],\n            'building_bounds': None\n        }\n\n        try:\n            # Combine all linear entities (lines and polylines) for wall analysis\n            wall_segments = []\n            \n            # Add lines as wall segments\n            for line in entities['lines']:\n                wall_segments.append({\n                    'start': line['start'],\n                    'end': line['end'],\n                    'layer': line['layer'],\n                    'length': line['length'],\n                    'type': 'line'\n                })\n            \n            # Add polyline segments\n            for polyline in entities['lwpolylines'] + entities['polylines']:\n                points = polyline['points']\n                for i in range(len(points) - 1):\n                    start, end = points[i], points[i + 1]\n                    length = math.sqrt((end[0] - start[0])**2 + (end[1] - start[1])**2)\n                    wall_segments.append({\n                        'start': start,\n                        'end': end,\n                        'layer': polyline['layer'],\n                        'length': length,\n                        'type': 'polyline_segment'\n                    })\n\n            # Group wall segments by connectivity and orientation\n            wall_groups = self._group_connected_walls(wall_segments)\n            analysis['wall_groups'] = wall_groups\n\n            # Find building bounds\n            all_points = []\n            for segment in wall_segments:\n                all_points.extend([segment['start'], segment['end']])\n            \n            if all_points:\n                min_x = min(p[0] for p in all_points)\n                max_x = max(p[0] for p in all_points)\n                min_y = min(p[1] for p in all_points)\n                max_y = max(p[1] for p in all_points)\n                analysis['building_bounds'] = {\n                    'min_x': min_x, 'max_x': max_x, \n                    'min_y': min_y, 'max_y': max_y,\n                    'width': max_x - min_x,\n                    'height': max_y - min_y\n                }\n\n            # Identify enclosed areas from closed polylines\n            for polyline in entities['lwpolylines'] + entities['polylines']:\n                if polyline.get('closed', False) and polyline.get('area', 0) > 0:\n                    analysis['enclosed_areas'].append({\n                        'points': polyline['points'],\n                        'area': polyline['area'],\n                        'layer': polyline['layer']\n                    })\n\n            print(f\"Found {len(wall_groups)} wall groups, {len(analysis['enclosed_areas'])} enclosed areas\")\n            return analysis\n\n        except Exception as e:\n            print(f\"Error analyzing spatial relationships: {e}\")\n            return analysis\n\n    def _group_connected_walls(self, wall_segments: List[Dict]) -> List[Dict]:\n        \"\"\"Group wall segments that are connected to each other (optimized with spatial indexing)\"\"\"\n        if not wall_segments:\n            return []\n\n        # Use spatial indexing for large datasets\n        if len(wall_segments) > 2000:\n            print(f\"Large dataset detected ({len(wall_segments)} segments). Using spatial indexing optimization.\")\n            return self._group_connected_walls_spatial(wall_segments)\n\n        groups = []\n        used_segments = set()\n        tolerance = 1.0\n        max_iterations = len(wall_segments) * 2  # More reasonable iteration limit\n\n        for i, segment in enumerate(wall_segments):\n            if i in used_segments:\n                continue\n\n            # Start a new group with this segment\n            group = {\n                'segments': [segment],\n                'total_length': segment['length'],\n                'layers': {segment['layer']},\n                'bounds': self._get_segment_bounds(segment)\n            }\n            used_segments.add(i)\n\n            # Find all segments connected to this group\n            found_connection = True\n            iterations = 0\n            while found_connection and iterations < max_iterations:\n                found_connection = False\n                iterations += 1\n                \n                for j, other_segment in enumerate(wall_segments):\n                    if j in used_segments:\n                        continue\n\n                    # Check if this segment connects to any segment in the group\n                    if self._segments_connected(group['segments'], other_segment, tolerance):\n                        group['segments'].append(other_segment)\n                        group['total_length'] += other_segment['length']\n                        group['layers'].add(other_segment['layer'])\n                        group['bounds'] = self._update_bounds(group['bounds'], other_segment)\n                        used_segments.add(j)\n                        found_connection = True\n                        break  # Process one connection per iteration\n\n            groups.append(group)\n\n        print(f\"Grouped {len(wall_segments)} segments into {len(groups)} wall groups\")\n        return groups\n\n    def _segments_connected(self, group_segments: List[Dict], segment: Dict, tolerance: float) -> bool:\n        \"\"\"Check if a segment is connected to any segment in a group\"\"\"\n        seg_start, seg_end = segment['start'], segment['end']\n        \n        for group_seg in group_segments:\n            group_start, group_end = group_seg['start'], group_seg['end']\n            \n            # Check if any endpoints are close enough\n            distances = [\n                math.sqrt((seg_start[0] - group_start[0])**2 + (seg_start[1] - group_start[1])**2),\n                math.sqrt((seg_start[0] - group_end[0])**2 + (seg_start[1] - group_end[1])**2),\n                math.sqrt((seg_end[0] - group_start[0])**2 + (seg_end[1] - group_start[1])**2),\n                math.sqrt((seg_end[0] - group_end[0])**2 + (seg_end[1] - group_end[1])**2)\n            ]\n            \n            if min(distances) <= tolerance:\n                return True\n        \n        return False\n\n    def _segments_connected_simple(self, group_segments: List[Dict], segment: Dict, tolerance: float) -> bool:\n        \"\"\"Simplified version for performance - only check connection to most recent segment in group\"\"\"\n        if not group_segments:\n            return False\n            \n        # Only check connection to the last added segment for better performance\n        last_segment = group_segments[-1]\n        seg_start, seg_end = segment['start'], segment['end']\n        group_start, group_end = last_segment['start'], last_segment['end']\n        \n        # Check if any endpoints are close enough\n        distances = [\n            math.sqrt((seg_start[0] - group_start[0])**2 + (seg_start[1] - group_start[1])**2),\n            math.sqrt((seg_start[0] - group_end[0])**2 + (seg_start[1] - group_end[1])**2),\n            math.sqrt((seg_end[0] - group_start[0])**2 + (seg_end[1] - group_start[1])**2),\n            math.sqrt((seg_end[0] - group_end[0])**2 + (seg_end[1] - group_end[1])**2)\n        ]\n        \n        return min(distances) <= tolerance\n\n    def _group_connected_walls_spatial(self, wall_segments: List[Dict]) -> List[Dict]:\n        \"\"\"Optimized wall grouping using spatial indexing for large datasets\"\"\"\n        if not wall_segments:\n            return []\n\n        # Create spatial index for faster lookups\n        tolerance = 1.0\n        grid_size = 10.0  # Grid cell size for spatial indexing\n        spatial_grid = defaultdict(list)\n\n        # Index all segments by their spatial location\n        for i, segment in enumerate(wall_segments):\n            start, end = segment['start'], segment['end']\n            points = [start, end]\n            \n            for point in points:\n                grid_x = int(point[0] // grid_size)\n                grid_y = int(point[1] // grid_size)\n                # Add to multiple grid cells to handle tolerance\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        spatial_grid[(grid_x + dx, grid_y + dy)].append(i)\n\n        groups = []\n        used_segments = set()\n        \n        for i, segment in enumerate(wall_segments):\n            if i in used_segments:\n                continue\n\n            # Start a new group with this segment\n            group = {\n                'segments': [segment],\n                'total_length': segment['length'],\n                'layers': {segment['layer']},\n                'bounds': self._get_segment_bounds(segment)\n            }\n            used_segments.add(i)\n\n            # Use BFS to find connected segments\n            to_process = [i]\n            \n            while to_process:\n                current_idx = to_process.pop(0)\n                current_segment = wall_segments[current_idx]\n                \n                # Find potential connections using spatial grid\n                candidates = set()\n                start, end = current_segment['start'], current_segment['end']\n                for point in [start, end]:\n                    grid_x = int(point[0] // grid_size)\n                    grid_y = int(point[1] // grid_size)\n                    for dx in [-1, 0, 1]:\n                        for dy in [-1, 0, 1]:\n                            candidates.update(spatial_grid.get((grid_x + dx, grid_y + dy), []))\n\n                # Check actual connections\n                for candidate_idx in candidates:\n                    if candidate_idx in used_segments:\n                        continue\n                    \n                    candidate_segment = wall_segments[candidate_idx]\n                    if self._segments_directly_connected(current_segment, candidate_segment, tolerance):\n                        group['segments'].append(candidate_segment)\n                        group['total_length'] += candidate_segment['length']\n                        group['layers'].add(candidate_segment['layer'])\n                        group['bounds'] = self._update_bounds(group['bounds'], candidate_segment)\n                        used_segments.add(candidate_idx)\n                        to_process.append(candidate_idx)\n\n            groups.append(group)\n\n        print(f\"Spatial indexing: Grouped {len(wall_segments)} segments into {len(groups)} wall groups\")\n        return groups\n\n    def _segments_directly_connected(self, seg1: Dict, seg2: Dict, tolerance: float) -> bool:\n        \"\"\"Check if two segments are directly connected (optimized)\"\"\"\n        seg1_start, seg1_end = seg1['start'], seg1['end']\n        seg2_start, seg2_end = seg2['start'], seg2['end']\n        \n        # Check if any endpoints are close enough\n        distances = [\n            math.sqrt((seg1_start[0] - seg2_start[0])**2 + (seg1_start[1] - seg2_start[1])**2),\n            math.sqrt((seg1_start[0] - seg2_end[0])**2 + (seg1_start[1] - seg2_end[1])**2),\n            math.sqrt((seg1_end[0] - seg2_start[0])**2 + (seg1_end[1] - seg2_start[1])**2),\n            math.sqrt((seg1_end[0] - seg2_end[0])**2 + (seg1_end[1] - seg2_end[1])**2)\n        ]\n        \n        return min(distances) <= tolerance\n\n    def _get_segment_bounds(self, segment: Dict) -> Dict:\n        \"\"\"Get bounding box for a segment\"\"\"\n        start, end = segment['start'], segment['end']\n        return {\n            'min_x': min(start[0], end[0]),\n            'max_x': max(start[0], end[0]),\n            'min_y': min(start[1], end[1]),\n            'max_y': max(start[1], end[1])\n        }\n\n    def _update_bounds(self, bounds: Dict, segment: Dict) -> Dict:\n        \"\"\"Update bounds to include a new segment\"\"\"\n        seg_bounds = self._get_segment_bounds(segment)\n        return {\n            'min_x': min(bounds['min_x'], seg_bounds['min_x']),\n            'max_x': max(bounds['max_x'], seg_bounds['max_x']),\n            'min_y': min(bounds['min_y'], seg_bounds['min_y']),\n            'max_y': max(bounds['max_y'], seg_bounds['max_y'])\n        }\n\n    def classify_wall_types(self, analysis: Dict) -> List[Dict]:\n        \"\"\"\n        Classify wall groups as interior, exterior, or garage-adjacent based on spatial analysis\n        \"\"\"\n        classified_walls = []\n        \n        if not analysis.get('wall_groups') or not analysis.get('building_bounds'):\n            return classified_walls\n\n        building_bounds = analysis['building_bounds']\n        perimeter_tolerance = 5.0  # Distance tolerance for perimeter detection\n\n        try:\n            for group in analysis['wall_groups']:\n                group_bounds = group['bounds']\n                \n                # Determine wall type based on position and characteristics\n                wall_type = 'interior'  # Default\n                \n                # Check if this wall group is on the building perimeter\n                is_perimeter = (\n                    abs(group_bounds['min_x'] - building_bounds['min_x']) <= perimeter_tolerance or\n                    abs(group_bounds['max_x'] - building_bounds['max_x']) <= perimeter_tolerance or\n                    abs(group_bounds['min_y'] - building_bounds['min_y']) <= perimeter_tolerance or\n                    abs(group_bounds['max_y'] - building_bounds['max_y']) <= perimeter_tolerance\n                )\n                \n                if is_perimeter:\n                    wall_type = 'exterior'\n\n                # Check for garage walls based on layer names or area characteristics\n                layer_names = [layer.lower() for layer in group['layers']]\n                if any('garage' in layer for layer in layer_names):\n                    wall_type = 'garage_adjacent'\n\n                # Generate coordinates for wall tracing\n                coordinates = self._generate_wall_trace_coordinates(group)\n\n                classified_walls.append({\n                    'type': wall_type,\n                    'coordinates': coordinates,\n                    'total_length': group['total_length'],\n                    'layer_suggestions': list(group['layers']),\n                    'bounds': group_bounds,\n                    'segment_count': len(group['segments'])\n                })\n\n            print(f\"Classified {len(classified_walls)} wall groups\")\n            return classified_walls\n\n        except Exception as e:\n            print(f\"Error classifying wall types: {e}\")\n            return classified_walls\n\n    def _generate_wall_trace_coordinates(self, wall_group: Dict) -> List[Tuple[float, float]]:\n        \"\"\"\n        Generate coordinate sequence for tracing a wall group\n        \"\"\"\n        segments = wall_group['segments']\n        if not segments:\n            return []\n\n        # For simple cases, just return the endpoints of all segments\n        # In a more sophisticated implementation, this would create optimized trace paths\n        coordinates = []\n        \n        for segment in segments:\n            coordinates.extend([segment['start'], segment['end']])\n\n        # Remove duplicate consecutive points\n        unique_coords = []\n        for coord in coordinates:\n            if not unique_coords or coord != unique_coords[-1]:\n                unique_coords.append(coord)\n\n        return unique_coords\n\n    def analyze_dxf_geometry(self, analyzer=None) -> Dict:\n        \"\"\"\n        Main method to analyze DXF geometry and return wall classifications\n        This replaces the hardcoded analysis in the original code\n        \"\"\"\n        print(\"Starting DXF geometric analysis...\")\n        \n        # Step 1: Extract all geometric entities\n        entities = self.extract_geometric_entities()\n        if not entities:\n            print(\"No geometric entities found\")\n            return self._create_fallback_analysis()\n\n        # Step 2: Analyze spatial relationships\n        spatial_analysis = self.analyze_spatial_relationships(entities)\n        \n        # Step 3: Use AI to enhance analysis if analyzer is provided and API key is available\n        if analyzer:\n            print(\"Checking AI analysis availability...\")\n            try:\n                # Check if OpenAI API key is available\n                import os\n                if os.environ.get(\"OPENAI_API_KEY\"):\n                    print(\"Integrating AI analysis with geometric data...\")\n                    # Prepare metadata for AI analysis\n                    analysis_metadata = {\n                        'entities_extracted': {\n                            'lines': len(entities.get('lines', [])),\n                            'polylines': len(entities.get('lwpolylines', [])) + len(entities.get('polylines', [])),\n                            'arcs': len(entities.get('arcs', [])),\n                            'circles': len(entities.get('circles', []))\n                        },\n                        'wall_groups_found': len(spatial_analysis.get('wall_groups', [])),\n                        'building_bounds': spatial_analysis.get('building_bounds')\n                    }\n                    \n                    # Use AI to enhance the spatial analysis with timeout handling\n                    import signal\n                    \n                    def timeout_handler(signum, frame):\n                        raise TimeoutError(\"AI analysis timed out\")\n                    \n                    # Set alarm for 15 seconds\n                    signal.signal(signal.SIGALRM, timeout_handler)\n                    signal.alarm(15)\n                    \n                    try:\n                        enhanced_analysis = analyzer.analyze_geometric_data(analysis_metadata, spatial_analysis)\n                        spatial_analysis = enhanced_analysis\n                        print(\"AI analysis integration completed\")\n                    except TimeoutError:\n                        print(\"AI analysis timed out. Proceeding with geometric-only analysis.\")\n                    finally:\n                        signal.alarm(0)  # Cancel alarm\n                else:\n                    print(\"OpenAI API key not configured. Proceeding with geometric-only analysis.\")\n                \n            except Exception as e:\n                print(f\"AI analysis failed: {str(e)}. Proceeding with geometric-only analysis.\")\n                # Continue with geometric analysis instead of failing completely\n        \n        # Step 4: Classify wall types (potentially enhanced by AI)\n        classified_walls = self.classify_wall_types_enhanced(spatial_analysis)\n        \n        # Step 5: Format result in the expected structure\n        result = {\n            'drawing_type': 'floor_plan',\n            'spaces': [],\n            'elements': [],\n            'analysis_metadata': {\n                'entities_extracted': {\n                    'lines': len(entities.get('lines', [])),\n                    'polylines': len(entities.get('lwpolylines', [])) + len(entities.get('polylines', [])),\n                    'arcs': len(entities.get('arcs', [])),\n                    'circles': len(entities.get('circles', []))\n                },\n                'wall_groups_found': len(classified_walls),\n                'building_bounds': spatial_analysis.get('building_bounds'),\n                'ai_enhanced': analyzer is not None,\n                'ai_insights': spatial_analysis.get('ai_insights', {}),\n                'ai_recommendations': spatial_analysis.get('ai_recommendations', [])\n            }\n        }\n\n        # Convert classified walls to the expected format\n        for i, wall in enumerate(classified_walls):\n            layer_name = self._generate_layer_name_enhanced(wall, i)\n            \n            result['spaces'].append({\n                'type': wall['type'],\n                'coordinates': wall['coordinates'],\n                'layer_name': layer_name,\n                'metadata': {\n                    'total_length': wall['total_length'],\n                    'segment_count': wall['segment_count'],\n                    'bounds': wall['bounds'],\n                    'ai_classification': wall.get('ai_classification', {}),\n                    'confidence': wall.get('ai_classification', {}).get('confidence', 0.5)\n                }\n            })\n\n        print(f\"Analysis complete: found {len(result['spaces'])} wall spaces\")\n        return result\n\n    def classify_wall_types_enhanced(self, analysis: Dict) -> List[Dict]:\n        \"\"\"\n        Enhanced wall classification that uses AI insights when available\n        \"\"\"\n        classified_walls = []\n        \n        if not analysis.get('wall_groups') or not analysis.get('building_bounds'):\n            return classified_walls\n\n        building_bounds = analysis['building_bounds']\n        perimeter_tolerance = 5.0\n        ai_insights = analysis.get('ai_insights', {})\n        wall_classifications = ai_insights.get('wall_classifications', [])\n\n        try:\n            for i, group in enumerate(analysis['wall_groups']):\n                group_bounds = group['bounds']\n                \n                # Start with geometric classification\n                wall_type = 'interior'  # Default\n                \n                # Check if this wall group is on the building perimeter\n                is_perimeter = (\n                    abs(group_bounds['min_x'] - building_bounds['min_x']) <= perimeter_tolerance or\n                    abs(group_bounds['max_x'] - building_bounds['max_x']) <= perimeter_tolerance or\n                    abs(group_bounds['min_y'] - building_bounds['min_y']) <= perimeter_tolerance or\n                    abs(group_bounds['max_y'] - building_bounds['max_y']) <= perimeter_tolerance\n                )\n                \n                if is_perimeter:\n                    wall_type = 'exterior'\n\n                # Check for garage walls based on layer names\n                layer_names = [layer.lower() for layer in group['layers']]\n                if any('garage' in layer for layer in layer_names):\n                    wall_type = 'garage_adjacent'\n\n                # Override with AI classification if available and confident\n                ai_classification = None\n                for classification in wall_classifications:\n                    if classification.get('group_index') == i:\n                        ai_classification = classification\n                        break\n                \n                if ai_classification and ai_classification.get('confidence', 0) > 0.7:\n                    wall_type = ai_classification.get('type', wall_type)\n                    print(f\"AI override: Wall group {i} classified as {wall_type} \"\n                          f\"(confidence: {ai_classification.get('confidence', 0):.2f})\")\n\n                # Generate coordinates for wall tracing\n                coordinates = self._generate_wall_trace_coordinates(group)\n\n                wall_data = {\n                    'type': wall_type,\n                    'coordinates': coordinates,\n                    'total_length': group['total_length'],\n                    'layer_suggestions': list(group['layers']),\n                    'bounds': group_bounds,\n                    'segment_count': len(group['segments'])\n                }\n                \n                # Add AI classification data if available\n                if ai_classification:\n                    wall_data['ai_classification'] = ai_classification\n\n                classified_walls.append(wall_data)\n\n            print(f\"Enhanced classification complete: {len(classified_walls)} wall groups\")\n            return classified_walls\n\n        except Exception as e:\n            print(f\"Error in enhanced wall classification: {e}\")\n            # Fall back to basic classification\n            return self.classify_wall_types(analysis)\n\n    def _generate_layer_name_enhanced(self, wall: Dict, index: int) -> str:\n        \"\"\"Generate layer name using AI suggestions when available\"\"\"\n        \n        # Check if AI suggested a layer name\n        ai_classification = wall.get('ai_classification', {})\n        suggested_layer = ai_classification.get('suggested_layer', '')\n        \n        if suggested_layer and suggested_layer.strip():\n            print(f\"Using AI suggested layer name: {suggested_layer}\")\n            return suggested_layer\n        \n        # Fall back to standard naming\n        wall_type = wall['type']\n        layer_map = {\n            'exterior': f'main_floor_exterior_wall_{index}',\n            'interior': f'main_floor_interior_wall_{index}',\n            'garage_adjacent': f'main_floor_garage_wall_{index}'\n        }\n        return layer_map.get(wall_type, f'main_floor_{wall_type}_wall_{index}')\n\n    def _generate_layer_name(self, wall_type: str, index: int) -> str:\n        \"\"\"Generate appropriate layer name based on wall type (legacy method)\"\"\"\n        layer_map = {\n            'exterior': f'main_floor_exterior_wall_{index}',\n            'interior': f'main_floor_interior_wall_{index}',\n            'garage_adjacent': f'main_floor_garage_wall_{index}'\n        }\n        return layer_map.get(wall_type, f'main_floor_{wall_type}_wall_{index}')\n\n    def _create_fallback_analysis(self) -> Dict:\n        \"\"\"Create a basic fallback analysis if no geometry is found\"\"\"\n        print(\"Creating fallback analysis with minimal structure\")\n        return {\n            'drawing_type': 'floor_plan',\n            'spaces': [{\n                'type': 'exterior',\n                'coordinates': [(0, 0), (100, 0), (100, 100), (0, 100), (0, 0)],\n                'layer_name': 'main_floor_exterior_wall_fallback',\n                'metadata': {\n                    'fallback': True,\n                    'message': 'No geometry detected - using minimal fallback'\n                }\n            }],\n            'elements': [],\n            'analysis_metadata': {\n                'fallback_used': True\n            }\n        }\n\ndef convert_pdf_to_image(pdf_path: str, output_path: Optional[str] = None) -> str:\n    \"\"\"\n    Convert PDF to image for AI analysis\n    Note: This is a simplified version. For production, you'd use pdf2image library\n    \"\"\"\n    if output_path is None:\n        output_path = pdf_path.replace('.pdf', '.png')\n    \n    print(f\"PDF to image conversion would happen here: {pdf_path} -> {output_path}\")\n    print(\"Note: For full implementation, install pdf2image library\")\n    \n    return output_path\n\ndef main():\n    \"\"\"\n    Demonstration of AutoCAD integration capabilities\n    \"\"\"\n    print(\"AutoCAD Integration Module\")\n    print(\"=========================\")\n    \n    # Create integration instance\n    autocad = AutoCADIntegration()\n    \n    # Create a new DXF document\n    autocad.create_new_dxf()\n    \n    # Create sample layers\n    print(\"\\nCreating sample layers...\")\n    autocad.create_layer(\"basement_interior_wall\", color=1)  # Red\n    autocad.create_layer(\"basement_exterior_wall\", color=2)  # Yellow\n    autocad.create_layer(\"main_floor_garage_wall\", color=3)  # Green\n    \n    # Draw sample elements\n    print(\"\\nDrawing sample elements...\")\n    \n    # Sample interior wall\n    interior_coords = [(0, 0), (100, 0), (100, 50), (0, 50), (0, 0)]\n    autocad.draw_polyline(interior_coords, \"basement_interior_wall\")\n    \n    # Sample exterior wall\n    exterior_coords = [(0, 0), (150, 0), (150, 80), (0, 80), (0, 0)]\n    autocad.draw_polyline(exterior_coords, \"basement_exterior_wall\")\n    \n    # Sample door\n    autocad.draw_rectangle((50, 0), (80, 10), \"basement_interior_wall\")\n    \n    # List all layers\n    print(\"\\nLayers in document:\")\n    layers = autocad.list_layers()\n    for layer in layers:\n        print(f\"  - {layer['name']} (Color: {layer['color']})\")\n    \n    # Save the file\n    output_file = \"sample_architectural_output.dxf\"\n    autocad.save_dxf(output_file)\n    \n    print(f\"\\nSample DXF file created: {output_file}\")\n    print(\"AutoCAD integration test completed successfully!\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":42110}},"version":1}